服务器下的硬盘主有机械硬盘、固态硬盘以及 raid 阵列，通常内核分配盘符的顺序是 `/dev/sda`、`/dev/sdb`… …。在系统启动过程中，内核会按照扫描到硬盘的顺序分配盘符（先分配直通的，再分配阵列）。在同一个硬盘槽位，热插拔硬盘，系统会顺着已存在的盘符分配下去，如之前分配的是 `/dev/sdb`，系统最后一块硬盘是 `/dev/sdf,`那么 `/dev/sdb/` 热拔插后，系统会重新分配这块硬盘的盘符为 `/dev/sdg`，出现盘符错乱的情况。

在此种情况下，可以用以下方法解决盘符错位的问题：

```bash
# 获取盘符信息
> udevadm info -q path -n /dev/sda

/devices/pci0000:00/0000:00:17.0/ata2/host1/target1:0:0/1:0:0:0/block/sda

# 将盘符信息写入 /etc/udev/rules.d/
> echo 'DEVPATH=="/devices/pci0000:00/0000:00:17.0/ata2/host1/target1:0:0/1:0:0:0/block/sda", NAME="sda", MODE="0660"' >> /etc/udev/rules.d/80-mydisk.rules
```

用个小脚本实现绑定所有的盘符和槽位

```bash
#!/bin/bash
disk="a b"
for i in ${disk};
   do
      a=`/usr/sbin/udevadm info -q path -n /dev/sd${i}`;
      if [ ! -n "$a" ]; then
          break 1 ;
      else
      echo DEVPATH=="\"${a}"\", NAME="\"sd${i}"\", MODE="\"0660"\">>/etc/udev/rules.d/80-mydisk.rules;
      fi
done
```

绑定 NVME 磁盘

```bash
#!/bin/bash
disk="0 1"
for i in ${disk};
   do
      a=`/usr/sbin/udevadm info -q path -n /dev/nvme${i}n1`;
      if [ ! -n "$a" ]; then
          break 1 ;
      else
      echo DEVPATH=="\"${a}"\", NAME="\"nvme${i}n1"\", MODE="\"0660"\">>/etc/udev/rules.d/80-mydisk.rules;
      fi
done
```

生成的  `/etc/udev/rules.d/80-mydisk.rules`

```plain
DEVPATH=="/devices/pci0000:00/0000:00:17.0/ata2/host1/target1:0:0/1:0:0:0/block/sda", NAME="sda", MODE="0660"
DEVPATH=="/devices/pci0000:00/0000:00:17.0/ata6/host5/target5:0:0/5:0:0:0/block/sdb", NAME="sdb", MODE="0660"
```

